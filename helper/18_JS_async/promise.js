const willWeGetAnswer = function () {
    return new Promise(function (resolve, reject) {
        setTimeout(function () {
            const isAddAngry = Math.random()>0.5;
            if(isAddAngry){
                const ignore = new Error(";)");
                reject(ignore);
            } else{
                const answer = {
                    code: "I am happy",
                    smile: ":)"
                }
                resolve(answer);//создает объект и внутриобъекта сразу будет Экзекьютор
            }
        }, 1000)
    })
}

//1 ВАРИАНТ сразу 2 Коллбека
// willWeGetAnswer()
// .then(result => console.log(result), e => console.log(e));//2 callbacks

//2 ВАРИАНТ catch
// willWeGetAnswer()
// .then(result => console.log(result))//здесь аргументом будет результат Резолв
// .catch(e => console.log(e));//2 callbacks

// //3 вариант вернуть результат коллбека и в следующем then что-то делать
// willWeGetAnswer()
// .then(result => result.code)//здесь аргументом будет результат Резолв
// .then(code => console.log(code))
// .catch(e => console.log(e));//2 callbacks

//4 вариант Promise - принимает что-то и возвращает новый Promise
willWeGetAnswer()
.then(result => result.code)//здесь аргументом будет результат Резолв
.then(code => {
    console.log(code)
    return willWeGetAnswer();//вернули Промис и тогда в след then через секунду появится какой-то новый результат
})
.then(result => result.code)//как только какой-то завершится ошибкой - сразу попадает в catch
.then(code => {
    console.log(code)
    return willWeGetAnswer();
})
.then(result => result.code)
.then(code => {
    console.log(code)
    return willWeGetAnswer();
})
.catch(e => console.log(e));//2 callbacks


//вызвали метод
//сначала поля не заполнены - будет андефайнд
//когда закончится работа поля будут заполнены
//

// промис чаще всего это функция вовращающая новый объект

// каждый следующий колбек прошлого
// когда нужно направить след запрос нужна инф из предыдущего
// нужно делать последовательно


// promise - это объект внутри которого инкапсулирована асинхронность
// у него есть методы обрабатывающие асинхронность
// у него есть конструктор, он принимает функцию
// два поля у конструктора: Стэйт и Резалт
// Экзекьютор это функция которая в качестве аргументов принимает 2 функции:
// резолв и реджект
// если запрос на сервер проходит - выполняется резолв, стэйт меняется на фулфилд, результат в поле резалт
// если ошибка - работает реджект, поле стэйт - реджектед, резалт: эррор

//у промиса 2 метода: resolve -> 
// then (функция которая будет выполняться в случае успешной работы промиса, передает в качестве аргумента результат обработки и пишем что хотим сделать с этим результатом)

//резалт можно поместить в следующий промис

//если промис с ошибкой: чаще всего в Зэн передается 2 функции:
//первая - что делать если все хорошо (стейт фулфилд)
//вторая - что делать если результат с ошибкой (стейт реджектед)
//можно написать всем Зэн если все хорошо - и потом Кетч (один в конце, если ошибка)
